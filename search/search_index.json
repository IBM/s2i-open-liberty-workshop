{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Source To Image Builder for Open Liberty Applications on OpenShift","text":"<p>This project contains a Source-to-Image (S2I) builder image and a S2I runtime image which creates an image running Java web applications on Open Liberty.</p> <p>Source-to-Image (S2I) is an open source toolkit for building reproducible container images from source code. S2I produces ready-to-run images by injecting source code into a container image.</p> <p>The Open Liberty builder can be used in two different environments:</p> <ul> <li>Local Docker runtime via 's2i',</li> <li>Deployment to OpenShift'.</li> </ul> <p>With interpreted languages like python and javascript, the runtime container is also the build container. For example, with a node.js application the 'npm install' is run to build the application and then 'npm start' is run in the same container in order to start the application.</p> <p>However, with compiled languages like Java, the build and runtime processes can be separated. This will allow for slimmer runtime containers for faster application starts and less bloat in the application image.</p> <p>This lab will focus on the second scenario of using a builder image along with a runtime image.</p> <p> (source: https://github.com/openshift/source-to-image/blob/master/docs/runtime_image.md)</p>"},{"location":"#structure-of-this-repository","title":"Structure of this repository","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<p>The following prerequisites are needed:</p> <ul> <li>Docker</li> <li>Source to Image CLI</li> <li>A Docker Hub account</li> <li>OpenShift CLI</li> <li>GitHub Account</li> <li>Git CLI</li> </ul>"},{"location":"#setup","title":"Setup","text":"<ol> <li> <p>Clone this repository locally and navigate to the newly cloned directory.</p> <pre><code>git clone https://github.com/IBM/s2i-open-liberty-workshop.git\ncd s2i-open-liberty-workshop\n</code></pre> </li> <li> <p>If you are running this lab in a browser based terminal environment like Skills Network and need to install the Source to Image CLI tool, follow this step:</p> <ol> <li>Run the setup script</li> </ol> <pre><code>chmod +x ./setup.sh\n./setup.sh\nexport PATH=$HOME/s2i:$PATH\n</code></pre> </li> <li> <p>To make things easier, we are going to set some environment variables that we can reuse in later commands.</p> <p>Note: Replace Your Username with your actual docker hub username. If you do not have one, go here to create one.</p> <pre><code>export ROOT_FOLDER=$(pwd)\nexport DOCKER_USERNAME=&lt;your-docker-username&gt;\n</code></pre> </li> <li> <p>Log in with your OpenShift Cluster.</p> </li> <li> <p>Open your <code>OpenShift web console</code> and from the profile dropdown <code>Copy Login Command</code>.</p> </li> <li> <p>Paste the login command to login, e.g.</p> <pre><code>oc login --token=&lt;login-token&gt; --server=https://&lt;cluster-subdomain&gt;:&lt;service-port&gt;\n</code></pre> </li> </ol>"},{"location":"#build-the-builder-image","title":"Build the builder image","text":"<p>In this section we will create the first of our two S2I images. This image will be responsible for taking in our source code and building the application binary with Maven.</p> <ol> <li> <p>Navigate to the builder image directory</p> <pre><code>cd ${ROOT_FOLDER}/builder-image\n</code></pre> </li> <li> <p>Review the ./Dockerfile</p> <pre><code>cat Dockerfile\n</code></pre> <ul> <li> <p>The image uses a Redhat certified Universal Base Image (UBI) from the public container registry at Redhat,</p> <pre><code>FROM registry.access.redhat.com/ubi8/ubi:8.1\n</code></pre> </li> </ul> </li> <li> <p>You can customize the builder image further, e.g. change the <code>LABEL</code> for <code>maintainer</code> to your name,</p> <pre><code>LABEL maintainer=\"&lt;your-name&gt;\"\n</code></pre> </li> <li> <p>Now build the builder image.</p> <pre><code>docker build -t $DOCKER_USERNAME/s2i-open-liberty-builder:0.1.0 .\n</code></pre> </li> <li> <p>Push the builder image out to Docker hub.</p> <pre><code>docker login\ndocker push $DOCKER_USERNAME/s2i-open-liberty-builder:0.1.0\n</code></pre> <p>With that done, you can now build your runtime image.</p> </li> </ol>"},{"location":"#build-the-runtime-image","title":"Build the runtime image","text":"<p>In this section you will create the second of our two S2I images. The runtime image will be responsible for taking the compiled binary from the builder image and serving it with the Open Liberty application server.</p> <ol> <li> <p>Navigate to the runtime image directory</p> <pre><code>cd $ROOT_FOLDER/runtime-image\n</code></pre> </li> <li> <p>Review the ./Dockerfile</p> <pre><code>cat Dockerfile\n</code></pre> </li> <li> <p>Build the runtime image</p> <pre><code>docker build -t $DOCKER_USERNAME/s2i-open-liberty:0.1.0 .\n</code></pre> </li> <li> <p>Push the runtime image to Docker hub.</p> <pre><code>docker push $DOCKER_USERNAME/s2i-open-liberty:0.1.0\n</code></pre> <p>Now we are ready to build our application with S2I.</p> </li> </ol>"},{"location":"#use-s2i-to-build-the-application-container","title":"Use S2I to build the application container","text":"<p>In this section, we will use S2I to build our application container image and then we will run the image locally using Docker.</p> <ol> <li> <p>Use the builder image and runtime image to build the application image</p> <pre><code>cd $ROOT_FOLDER/web-app\n</code></pre> </li> <li> <p>Run a multistage S2I build, to build the application.</p> <pre><code>s2i build . $DOCKER_USERNAME/s2i-open-liberty-builder:0.1.0 authors --runtime-image $DOCKER_USERNAME/s2i-open-liberty:0.1.0 -a /tmp/src/target -a /tmp/src/server.xml\n</code></pre> <p>Let's break down the above command:</p> <ul> <li><code>s2i build .</code>: Use <code>s2i build</code> in the current directory to build the Docker image by combining the builder image and sources</li> <li><code>$DOCKER_USERNAME/s2i-open-liberty-builder:0.1.0</code>: This is the builder image used to build the application</li> <li><code>authors</code>: name of our application image</li> <li><code>--runtime-image $DOCKER_USERNAME/s2i-open-liberty:0.1.0</code>: Take the output of the builder image and run it in this container.</li> <li><code>-a /tmp/src/target -a /tmp/src/server.xml</code>: The <code>runtime-artifact</code> flag specifies a file or directory to be copies from builder to runtime image. The runtime-artifact is where the builder output is located. These files will be passed into the runtime image.</li> </ul> </li> <li> <p>Run the newly built image to start the application on your local machine in the background,</p> <pre><code>docker run -d --rm -p 9080:9080 authors\n</code></pre> </li> <li> <p>Retrieve the authors using curl,</p> <pre><code>curl -X GET \"http://localhost:9080/api/v1/getauthor\" -H \"accept: application/json\"\n</code></pre> </li> <li> <p>Or open up your browser and navigate to http://localhost:9080/openapi/ui to view your deployed microservice.</p> </li> </ol>"},{"location":"#deployment-to-openshift","title":"Deployment to OpenShift","text":"<p>In the following labs we will be using two deployment strategies:</p> <ul> <li>manually deploy as a traditional Kubernetes <code>Deployment</code>, and</li> <li>automatic build and deployment using OpenShift <code>BuildConfig</code> and <code>DeploymentConfig</code>.</li> </ul> <p>Both ways are very similar, the main difference being that with OpenShift BuildConfig and DeploymentConfig we can set triggers to automatically build the application when a new image tag has been pushed to the internal registry.</p> <p>Now that we have the application running locally and have verified that it works, let's deploy it to an OpenShift environment.</p> <ol> <li> <p>In order to deploy to OpenShift, we need to push our images to your cluster's internal registry. First, run the following commands to authenticate with your OpenShift image registry.</p> <pre><code>oc patch configs.imageregistry.operator.openshift.io/cluster --patch '{\"spec\":{\"defaultRoute\":true}}' --type=merge\n\nexport REGISTRY=$(oc get route default-route -n openshift-image-registry --template='{{ .spec.host }}')\necho $REGISTRY\n\ndocker login -u $(oc whoami) -p $(oc whoami -t) $REGISTRY\n</code></pre> </li> </ol>"},{"location":"#deploying-as-a-traditional-kubernetes-deployment","title":"Deploying as a traditional Kubernetes deployment","text":"<p>For this method, we will deploy our application by creating a kubernetes deployment along with a service and a route.</p> <ol> <li> <p>Tag the image that was created in the previous section.</p> <pre><code>export IMAGE=docker.io/$DOCKER_USERNAME/authors:0.1.0\necho $IMAGE\ndocker tag authors $IMAGE\n</code></pre> </li> <li> <p>Push the image that we built locally using s2i to the OpenShift image registry.</p> <pre><code>docker push $IMAGE\n</code></pre> </li> <li> <p>Go back to the root folder,</p> <pre><code>cd $ROOT_FOLDER\n</code></pre> </li> <li> <p>Review the <code>application.yaml</code> file,</p> <pre><code>sed -i \"s|APPLICATION_IMAGE|$IMAGE|\" application.yaml\ncat application.yaml\n</code></pre> </li> <li> <p>Apply the <code>application.yaml</code> file using the <code>oc</code> cli to create our Deployment, Service, and Route.</p> <pre><code>oc apply -f application.yaml\n</code></pre> </li> <li> <p>Now let's visit the deployed application. Run the following to get the route to access the application.</p> <pre><code>oc get routes -l app=authors -o go-template='{{range .items}}{{.spec.host}}{{end}}'\n</code></pre> </li> <li> <p>Copy and paste the output of the previous command to set a variable $APP_URL,</p> <pre><code>export APP_URL=&lt;get-routes-output&gt;\n</code></pre> </li> <li> <p>Test the application using curl</p> <pre><code>curl -X GET \"http://$APP_URL/api/v1/getauthor\" -H \"accept: application/json\"\n</code></pre> </li> <li> <p>Or use the route to your app and paste it into your web browser and add the following to the end of the route:</p> <pre><code>/openapi/ui\n</code></pre> <p>So your route should appear like the following but without the (...):</p> <pre><code>authors-route-default...appdomain.cloud/openapi/ui\n</code></pre> <p>It sometimes takes a minute to fully deploy so if you get a message about the application not being available, try again.</p> <p>You should now see the OpenAPI documentation for the getAuthor endpoint of your microservice.</p> </li> </ol>"},{"location":"#automating-deployment-with-buildconfig-and-deploymentconfig","title":"Automating deployment with BuildConfig and DeploymentConfig","text":"<p>For this section, you will explore how to automate our application build and deploy using OpenShift concepts known as build config and deployment config. With build configs, the s2i builds are actually happening on the cluster rather than locally.</p> <ol> <li> <p>Tag our builder and runtime images for OpenShift registry.</p> <pre><code>docker tag $DOCKER_USERNAME/s2i-open-liberty-builder:0.1.0 $REGISTRY/default/s2i-open-liberty-builder:0.1.0\n\ndocker tag $DOCKER_USERNAME/s2i-open-liberty:0.1.0 $REGISTRY/default/s2i-open-liberty:0.1.0\n</code></pre> </li> <li> <p>Push the images to the registry.</p> <pre><code>docker push $REGISTRY/default/s2i-open-liberty-builder:0.1.0\n\ndocker push $REGISTRY/default/s2i-open-liberty:0.1.0\n</code></pre> </li> <li> <p>We are almost ready to deploy our application but first we need to create an application template that contains all the components of our application. See Using Templates.</p> </li> <li> <p>Review the <code>template.yaml</code> file, which contains the BuildConfig object and the DeploymentConfig object as well as the other application objects,</p> <pre><code>cat template.yaml\n</code></pre> </li> <li> <p>The template file that we will apply, creates the following Kubernetes objects:</p> <ul> <li>Template,</li> <li>4 ImageStream objects: authors-builder, authors-runtime, s2i-open-liberty-builder, s2i-open-liberty</li> <li>2 BuildConfig objects: the <code>open-liberty-builder</code> produces a <code>authors-builder:0.1.0</code> from <code>s2i-open-liberty-builder:0.1.0</code>; and the <code>open-liberty-app</code> produces an <code>authors-runtime:0.1.0</code> from <code>s2i-open-liberty:0.1.0</code>. The former build config is for the builder image and the latter is for the runtime image.</li> <li>DeploymentConfig for <code>authors-runtime:0.1.0</code> to manage the application Pods and ReplicationController,</li> <li>Service, and</li> <li>Route.</li> </ul> <pre><code>oc apply -f template.yaml\n</code></pre> </li> <li> <p>Lastly, we can use the <code>oc</code> cli to deploy the application while using the template that was just created.</p> <pre><code>oc new-app --template open-liberty-app -p DOCKER_USERNAME=$DOCKER_USERNAME\n</code></pre> <p>After running the command you may see a message that says <code>Failed</code> however this is because the build has not yet completed.</p> <pre><code>...\n--&gt; Creating resources ...\n    imagestream.image.openshift.io \"authors-builder\" created\n    imagestream.image.openshift.io \"authors-runtime\" created\n    error: imagestreams.image.openshift.io \"s2i-open-liberty-builder\" already exists\n    imagestream.image.openshift.io \"s2i-open-liberty\" created\n    buildconfig.build.openshift.io \"open-liberty-builder\" created\n    buildconfig.build.openshift.io \"open-liberty-app\" created\n    deploymentconfig.apps.openshift.io \"authors2\" created\n    service \"authors2\" created\n    route.route.openshift.io \"authors2\" created\n--&gt; Failed\n</code></pre> </li> <li> <p>If you log into your OpenShift console and navigate to <code>Builds</code> &gt; <code>Builds</code> you should see your builds running.</p> </li> <li> <p>Or list all builds,</p> <pre><code>oc get builds\nNAME                     TYPE     FROM          STATUS     STARTED          DURATION\nopen-liberty-builder-1   Source   Git@7fe598c   Complete   21 minutes ago   1m11s\n</code></pre> </li> <li> <p>Describe the build to review the status,</p> <pre><code>oc get build open-liberty-builder-1\nNAME                     TYPE     FROM          STATUS     STARTED          DURATION\nopen-liberty-builder-1   Source   Git@7fe598c   Complete   23 minutes ago   1m11s\n</code></pre> </li> <li> <p>Once those builds complete a replication controller will be created that manages the application pods. Navigate to <code>Workloads</code> &gt; <code>Pods</code> and look for your new pod. It should start with <code>authors-</code>.</p> <pre><code>oc get pods\nNAME                                  READY   STATUS      RESTARTS   AGE\nauthors-deployment-5df596c88f-7vcgb   1/1     Running     0          56m\nopen-liberty-builder-1-build          0/1     Completed   0          25m\n</code></pre> </li> <li> <p>Once you have verified that the new pod is running, enter the following command to view the application routes.</p> <pre><code>oc get routes\n\nNAME    HOST/PORT    PATH    SERVICES    PORT    TERMINATION    WILDCARD\nauthors-route    authors-route-default.your-roks-43-1n-cl-2bef1f4b4097001da9502000c44fc2b2-0000.us-south.containers.appdomain.cloud    authors-service    http    None\nauthors2    authors2-default.your-roks-43-1n-cl-2bef1f4b4097001da9502000c44fc2b2-0000.us-south.containers.appdomain.cloud    authors2    9080    None\n</code></pre> </li> <li> <p>Use the route named <code>authors2</code> and append <code>/openapi/ui</code> after the <code>HOST/PORT</code> value to open the UI, or append <code>/api/v1/getauthor</code> to set the API_URL. View the sample below, however, you will have a different route.</p> <pre><code>export API_URL=authors2-default.osgdcw01-0e3e0ef4c9c6d831e8aa6fe01f33bfc4-0000.sjc04.containers.appdomain.cloud\n</code></pre> <p>Then test your application with the command below:</p> <pre><code>curl -X GET \"http://$API_URL/api/v1/getauthor\" -H \"accept: application/json\"\n</code></pre> </li> </ol>"},{"location":"#optional-configure-a-github-webhook-for-automating-builds","title":"Optional: Configure a GitHub Webhook for automating builds","text":"<p>In this optional section we will explore the option of configuring a webhook that will automatically notify OpenShift of a git push and will kick off the build and deploy process.</p> <ol> <li> <p>First we need to create your own version of the code repo by creating a fork. This will copy the repo into your GitHub account. Navigate to the lab repo at https://github.com/IBM/s2i-open-liberty-workshop and click on the Fork button in the upper right of the page.</p> </li> <li> <p>When the repo is done forking, click on the green Clone or download button and copy your git repo url.</p> </li> <li> <p>Then, in your terminal, navigate to a directory where you'd like to clone your repo locally and run the following commands while substituting  with the url you copied in the previous step: <pre><code>cd /home/project\nmkdir clone\ncd clone\ngit clone &lt;repo_url&gt;\ncd s2i-open-liberty-workshop/\n</code></pre> <li> <p>First let's delete the application that we deployed earlier. Run the following script:</p> <pre><code>./delete.sh\n</code></pre> </li> <li> <p>Then run the following command to redeploy the application, this time we will specify to point to your newly created repo. Replace \\&lt;repo url&gt; with the url to the GitHub repo that you copied earlier.</p> <pre><code>oc new-app --template open-liberty-app -p SOURCE_REPOSITORY_URL=&lt;repo url&gt; -p APP_NAME=authors-3 -p DOCKER_USERNAME=$DOCKER_USERNAME\n</code></pre> </li> <li> <p>Now you should see some output of the components that have been created as well as a section labled With parameters:</p> <pre><code>    * With parameters:\n        * Source URL=https://github.com/odrodrig/s2i-open-liberty.git\n        * App name=authors-3\n        * Source Branch=master\n        * Source Directory=/web-app\n        * Output Directory=/tmp/src/\n        * GitHub Webhook Secret=xxxxxxxx # generated\n</code></pre> </li> <li> <p>Copy the GitHub Webhook Secret into a text document and save it for later.</p> </li> <li> <p>In your terminal run the following command to get the webhook endpoint:</p> <pre><code>oc describe bc open-liberty-builder\n</code></pre> <p>Look for the section labeled Webhook GitHub. It should look like the example below.</p> <pre><code>Webhook GitHub:\n    URL: https://c107-e.us-south.containers.cloud.ibm.com:31689/apis/build.openshift.io/v1/namespaces/default/buildconfigs/open-liberty-builder/webhooks/&lt;secret&gt;/github\n</code></pre> <p>Replace the \\&lt;secret&gt; portion from the url copied in the previous step with the secret you copied earlier.</p> </li> <li> <p>Then, in your browser, navigate to your git repo and find the Settings tab.</p> </li> <li> <p>From the project settings select Webhooks on the left side of the page and click on new webhook.</p> </li> <li> <p>In the payload url field, enter the webhook url that you copied earlier with the included secret.</p> </li> <li> <p>For the content type, select application/json</p> </li> <li> <p>Then, click Add webhook</p> <p>You should now see a webhook listed in the project settings. Ensure that the webhook has a green checkmark next to it. If there is a red X, try creating the webhook again.</p> </li> <li> <p>Now that the webhook is configured, let's push a change and test it out. From your code editor of choice, navigate to the repo that you cloned and open <code>web-app/src/main/java/com/ibm/authors/GetAuthor.java</code></p> </li> <li> <p>On lines 56-59 edit the name, twitter, and blog to your own information or fake information if you'd like.</p> <pre><code>Author author = new Author();\n    author.name = \"Oliver Rodriguez\";\n    author.twitter = \"https://twitter.com/heres__ollie\";\n    author.blog = \"http://developer.ibm.com\";\n</code></pre> </li> <li> <p>Save the file.</p> </li> <li> <p>From your terminal and within your cloned repo run the following commands after replacing the email address and name with your own information. This is the email address used to sign into github.</p> <pre><code>git config --global user.email \"you@example.com\"\ngit config --global user.name \"Your Name\"\n</code></pre> <pre><code>git add .\ngit commit -m \"Changed author info\"\ngit push\n</code></pre> <p>With the changes pushed, we can now go to the OpenShift dashboard and view the builds that have been kicked by the GitHub webhook.</p> </li> <li> <p>In your browser, go back into your OpenShift console and navigate to <code>Builds</code> &gt; <code>Builds</code> and you should see your builds running.</p> </li> <li> <p>After the builds are completed, navigate to <code>Workloads</code> &gt; <code>Pods</code> and look for your new pod. It should start with <code>authors-3</code>.</p> </li> <li> <p>Once you have verified that the new pod is running, enter the following command to view the application routes.</p> <pre><code>oc get routes\n\nNAME    HOST/PORT    PATH    SERVICES    PORT    TERMINATION    WILDCARD\nauthors-route    authors-route-default.your-roks-43-1n-cl-2bef1f4b4097001da9502000c44fc2b2-0000.us-south.containers.appdomain.cloud    authors-service    http    None\nauthors2    authors2-default.your-roks-43-1n-cl-2bef1f4b4097001da9502000c44fc2b2-0000.us-south.containers.appdomain.cloud    authors2    9080    None\n</code></pre> </li> <li> <p>Use the route named <code>authors-3</code> and append <code>/openapi/ui</code> after the <code>HOST/PORT</code> value to open the UI, or append <code>/api/v1/getauthor</code> to set the API_URL. View the sample below, however, you will have a different route.</p> <pre><code>export API_URL=authors-3-default.osgdcw01-0e3e0ef4c9c6d831e8aa6fe01f33bfc4-0000.sjc04.containers.appdomain.cloud\n</code></pre> <p>Then test your application with the command below:</p> <pre><code>curl -X GET \"http://$API_URL/api/v1/getauthor\" -H \"accept: application/json\"\n</code></pre> </li> <p>You should then see the info that you edited in the file earlier.</p>"},{"location":"#conclusion","title":"Conclusion","text":"<p>In this lab we have explored building our own custom s2i images for building containerized application from source code. We utilized a multi stage s2i process that separated the build environment from the runtime environment which allowed for us to have a slimmer application image. Then, we deployed the application as a traditional Kubernetes deployment. Lastly, we explored how to automate the building and deploying of the application using OpenShift build and deployment configs.</p>"},{"location":"SUMMARY/","title":"Table of contents","text":"<ul> <li>Lab - S2I Open Liberty</li> </ul>"}]}